<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Single-File Editor</title>
  <!-- Google Fonts (Top 15 Popular) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script&family=Lato&family=Merriweather&family=Montserrat&family=Noto+Sans&family=Open+Sans&family=Oswald&family=Pacifico&family=Playfair+Display&family=Poppins&family=Raleway&family=Roboto&family=Roboto+Mono&family=Source+Sans+Pro&family=Ubuntu&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --accent: #22c55e;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --border: #334155;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--text); }
    header { display:flex; align-items:center; justify-content:space-between; padding: 12px 16px; border-bottom: 1px solid var(--border); background: #0b1220; position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 18px; letter-spacing: 0.3px; }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .toolbar-group { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .toolbar select, .toolbar input[type="number"], .toolbar input[type="text"], .toolbar button, .toolbar label {
      background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 8px 10px; font-size: 14px;
    }
    .toolbar button { cursor: pointer; }
    .toolbar button.primary { background: var(--accent); color: #052814; border: none; font-weight: 600; }
    .toolbar button:disabled { opacity: 0.6; cursor: not-allowed; }
    .toolbar .sep { width:1px; height:28px; background: var(--border); margin: 0 4px; }

    main { display:grid; grid-template-columns: 1fr; gap: 12px; padding: 12px; }
    .controls { display:flex; flex-direction:column; gap:8px; }

  .canvas-wrap { background: #f0f0f0; border:1px solid var(--border); border-radius: 10px; display:flex; align-items:center; justify-content:center; min-height: 70vh; position: relative; overflow:auto; }
  /* Fix: Do not set background on 'canvas' tag directly, as Fabric.js creates an upper canvas overlay that must remain transparent. */
  .canvas-container { background: #ffffff; box-shadow: 0 0 0 1px var(--border) inset; }

    footer { padding: 12px 16px; border-top: 1px solid var(--border); color: var(--muted); }
    .hint { color: var(--muted); font-size: 12px; }
    a.link { color: #93c5fd; text-decoration: none; }
  </style>
  <!-- Fabric.js loaded locally for reliability -->
  <script src="https://cdn.jsdelivr.net/npm/fabric@4.6.0/dist/fabric.min.js"></script>
</head>
<body>
  <header>
    <div class="toolbar">
      <!-- Level 1: Always Visible -->
      <div id="toolbar-main" class="toolbar-group">
        <label>
          Item:
          <select id="bgSelect">
            <option value="">None</option>
            <option value="w_pen.png">Wooden Pen</option>
            <option value="cuttlery.png">Cuttlery</option>
                                    <option value="chopstix.png">Chopsticks</option>

            <option value="tumbler.png">Tumbler</option>
            <option value="mug.png">Mug</option>
            <option value="notebook.png">Notebook</option>
            <option value="kc_round.jpg">Keychain-Round</option>
            <option value="kc_rect.jpg">Keychain-Rectangle</option>
                        <option value="chopping_board.png">Chopping Board</option>
                        <option value="pizza_plate.png">Pizza Plate Board</option>

          </select>
        </label>

        <button id="rotateBgBtn" title="Rotate Background 90Â°">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z"/></svg>
        </button>

        <button id="addTextBtn" title="Add Text">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M5 4v3h5.5v12h3V7H19V4z"/></svg>
        </button>

        <input id="imageInput" type="file" accept="image/*" style="display:none" />
        <button id="insertImageBtn" title="Insert Image">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
        </button>

        <div class="sep"></div>

        <!-- Edit/Arrange Group -->
        <button id="toggleEditBtn" title="Edit & Arrange">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/></svg>
        </button>
        <div id="editControlsExtra" style="display:none; align-items:center; gap:4px;">
            <button id="duplicateBtn" title="Duplicate Selected">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
            </button>
            <button id="deleteBtn" title="Delete Selected">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
            </button>
            <button id="bringForwardBtn" title="Bring Forward">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M8 11h3v10h2V11h3l-4-4-4 4zM4 3v2h16V3H4z"/></svg>
            </button>
            <button id="sendBackwardsBtn" title="Send Backward">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M16 13h-3V3h-2v10H8l4 4 4-4zM4 19v2h16v-2H4z"/></svg>
            </button>
            <button id="invertBtn" title="Invert Colors">
              <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31s8.19 3.12 11.31 0c3.12-3.12 3.12-8.19 0-11.31-3.12-3.12-8.19-3.12-11.31 0zM12 17.17V6.83c2.86.29 5.13 2.56 5.42 5.42-.29 2.86-2.56 5.13-5.42 5.42z"/></svg>
            </button>
        </div>

        <div class="sep"></div>

        <!-- Export Group -->
        <button id="toggleExportBtn" title="Share & Export">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/></svg>
        </button>
        <div id="exportControlsExtra" style="display:none; align-items:center; gap:4px;">
            <button id="exportBtn" class="primary">PNG</button>
            <button id="exportSvgBtn">SVG</button>
            <button id="emailBtn">Email</button>
        </div>
      </div>

      <!-- Level 2: Text Selected -->
      <div id="toolbar-text" class="toolbar-group" style="display:none; border-left: 1px solid var(--border); padding-left: 8px;">
        <select id="fontFamily">
          <option value="Arial">Arial</option>
          <option value="Arial Black">Arial Black</option>
          <option value="Brush Script MT">Brush Script MT</option>
          <option value="Comic Sans MS">Comic Sans MS</option>
          <option value="Courier New">Courier New</option>
          <option value="Georgia">Georgia</option>
          <option value="Helvetica">Helvetica</option>
          <option value="Impact">Impact</option>
          <option value="Tahoma">Tahoma</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Trebuchet MS">Trebuchet MS</option>
          <option value="Verdana">Verdana</option>
        </select>
        
        <button id="toggleFontControlsBtn" title="Font Settings" style="font-weight:bold; font-family:serif;">Aa</button>

        <div id="fontControlsExtra" style="display:none; align-items:center; gap:8px;">
            <button id="loadFontsBtn" title="Load local system fonts">Local</button>
            
            <input id="googleFontInput" type="text" placeholder="Google Font" style="width: 100px;" />
            <button id="loadGoogleFontBtn">Get</button>
            
            <input id="fontSize" type="number" min="8" max="200" step="1" value="32" style="width: 60px;" />
            <button id="boldBtn" title="Bold">
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>
            </button>
            <button id="italicBtn" title="Italic">
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z"/></svg>
            </button>
        </div>
        
        <div class="sep"></div>

        <!-- Paragraph Group -->
        <button id="toggleParagraphBtn" title="Paragraph & Style">
          <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M3 21h18v-2H3v2zm0-4h12v-2H3v2zm0-4h18v-2H3v2zm0-4h12V7H3v2zm0-6v2h18V3H3z"/></svg>
        </button>
        <div id="paragraphControlsExtra" style="display:none; align-items:center; gap:8px;">
            <button id="alignLeftBtn" title="Align Left">
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M3 21h18v-2H3v2zm0-4h12v-2H3v2zm0-4h18v-2H3v2zm0-4h12V7H3v2zm0-6v2h18V3H3z"/></svg>
            </button>
            <button id="alignCenterBtn" title="Align Center">
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/></svg>
            </button>
            <button id="alignRightBtn" title="Align Right">
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zm-6-6v2h18V3H3z"/></svg>
            </button>
            
            <label title="Text Border Width">
              Border: <input id="textBorder" type="number" min="0" max="20" step="0.5" value="0" style="width: 50px;" />
            </label>
            
            <label title="Character Spacing">
              Spacing: <input id="charSpacing" type="range" min="-200" max="800" value="0" step="10" style="width: 80px;" />
            </label>
        </div>

        <div class="sep"></div>
        <button id="circularTextBtn" title="Toggle Circular Text">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/><circle cx="12" cy="12" r="5"/></svg>
        </button>
        <label style="display:none;" id="flipCurveLabel">
          <input id="flipCurve" type="checkbox" /> Flip
        </label>
      </div>

      <!-- Level 3: Image Selected - Removed as Invert is now main -->
      <!-- <div id="toolbar-image" ...></div> -->
    </div>
  </header>

  <main>
    <!-- Left project panel removed per request; canvas now occupies full width -->
    <section class="canvas-wrap">
      <canvas id="c" width="1024" height="1024"></canvas>
      <button id="fixedLockBtn" title="Lock/Unlock Selection" style="position: absolute; top: 10px; right: 10px; z-index: 100; background: var(--panel); border: 1px solid var(--border); border-radius: 50%; width: 40px; height: 40px; display: none; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <span id="lockIcon" style="font-size: 20px;">ðŸ”“</span>
      </button>
    </section>
  </main>

  <footer>
    Export downloads a PNG locally. Email opens your mail client with a prefilled message. To auto-send emails, you need a small backend; see notes below.
  </footer>

  <script>
    // Defer initialization until window load to ensure scripts and DOM are ready
    window.addEventListener('load', () => {
      // Guard: ensure Fabric.js loaded
      if (typeof fabric === 'undefined') {
        alert('Fabric.js failed to load. Please check your internet connection or use a local server.');
        return;
      }

      // Customize Fabric selection controls (Thicker lines, larger handles for mobile)
      fabric.Object.prototype.set({
        transparentCorners: false,
        cornerColor: '#ffffff',
        cornerStrokeColor: '#22c55e', // Accent color
        borderColor: '#22c55e',
        cornerSize: 40,        // Even larger handles
        padding: 15,           // More space around object
        cornerStyle: 'circle', // Modern rounded corners
        borderScaleFactor: 4,  // Thicker border line
        rotatingPointOffset: 150 // Even longer stem for rotation
      });

      // Initialize Fabric canvas
      const canvas = new fabric.Canvas('c', {
        backgroundColor: '#ffffff',
        preserveObjectStacking: true,
        selection: false, // Disable group selection to allow panning
        enableRetinaScaling: false,
        width: 1024, // Explicit width
        height: 1024 // Explicit height (Square)
      });
      
      // Force a render immediately to ensure canvas is ready
      canvas.renderAll();

      // Limit rotation to 15 degree steps
      canvas.on('object:rotating', (e) => {
        e.target.angle = Math.round(e.target.angle / 15) * 15;
      });

      // Dynamic Rotation Stem: Set length to 1/2 the longer side of the object
      function adjustRotationStem(e) {
          const obj = e.target;
          if (!obj) return;
          const dim = Math.max(obj.getScaledWidth(), obj.getScaledHeight());
          // Set stem to 1/2 longer side, but keep a minimum of 60px for touch usability
          obj.set('rotatingPointOffset', Math.max(60, dim / 2)); 
      }
      canvas.on('selection:created', adjustRotationStem);
      canvas.on('selection:updated', adjustRotationStem);
      canvas.on('object:scaling', adjustRotationStem);

      // Panning Logic (Mouse/Touch Drag on background)
      let isDragging = false;
      let lastPosX;
      let lastPosY;

      // Smart Selection Bias: Track last active object to prevent accidental panning
      let lastSelected = null;
      canvas.on('selection:created', (e) => lastSelected = e.target);
      canvas.on('selection:updated', (e) => lastSelected = e.target);
      canvas.on('object:removed', (e) => {
          if (e.target === lastSelected) lastSelected = null;
      });

      canvas.on('mouse:down', function(opt) {
        const evt = opt.e;
        // If user clicks an object, don't pan
        if (opt.target) {
            lastSelected = opt.target;
            return;
        }
        
        // Bias: If clicking near the previously selected object, re-select it and don't pan
        if (lastSelected && canvas.getObjects().includes(lastSelected)) {
            const pointer = canvas.getPointer(evt);
            const bound = lastSelected.getBoundingRect();
            const pad = 60; // 60px buffer around object
            
            if (pointer.x >= bound.left - pad &&
                pointer.x <= bound.left + bound.width + pad &&
                pointer.y >= bound.top - pad &&
                pointer.y <= bound.top + bound.height + pad) {
                
                // Restore selection if lost
                if (!canvas.getActiveObject()) {
                    canvas.setActiveObject(lastSelected);
                    canvas.requestRenderAll();
                }
                return; // Skip panning
            }
        }
        
        // If we are here, we truly clicked the background
        lastSelected = null;
        
        isDragging = true;
        canvas.selection = false; 
        // Handle both mouse and touch events for coordinates
        if (evt.type === 'touchstart') {
            const touch = evt.touches[0];
            lastPosX = touch.clientX;
            lastPosY = touch.clientY;
        } else {
            lastPosX = evt.clientX;
            lastPosY = evt.clientY;
        }
        canvas.setCursor('grabbing');
      });

      canvas.on('mouse:move', function(opt) {
        if (isDragging) {
          const evt = opt.e;
          let clientX, clientY;
          
          if (evt.type === 'touchmove') {
              const touch = evt.touches[0];
              clientX = touch.clientX;
              clientY = touch.clientY;
          } else {
              clientX = evt.clientX;
              clientY = evt.clientY;
          }

          const vpt = canvas.viewportTransform;
          vpt[4] += clientX - lastPosX;
          vpt[5] += clientY - lastPosY;
          canvas.requestRenderAll();
          lastPosX = clientX;
          lastPosY = clientY;
        }
      });

      canvas.on('mouse:up', function(opt) {
        if(isDragging) {
            canvas.setViewportTransform(canvas.viewportTransform);
            isDragging = false;
            canvas.setCursor('default');
        }
      });

      // Fixed Lock Button Logic
      const fixedLockBtn = document.getElementById('fixedLockBtn');
      const lockIcon = document.getElementById('lockIcon');

      function updateLockUI() {
        const obj = canvas.getActiveObject();
        if (!obj) {
            fixedLockBtn.style.display = 'none';
            return;
        }
        
        fixedLockBtn.style.display = 'flex';
        const isLocked = obj.lockMovementX; // Check one property, assuming all are synced
        lockIcon.textContent = isLocked ? 'ðŸ”’' : 'ðŸ”“';
        fixedLockBtn.style.background = isLocked ? '#fee2e2' : 'var(--panel)';
        fixedLockBtn.style.borderColor = isLocked ? '#ef4444' : 'var(--border)';
      }

      fixedLockBtn.addEventListener('click', () => {
        const obj = canvas.getActiveObject();
        if (!obj) return;

        const isLocked = obj.lockMovementX;
        const newState = !isLocked;

        // Toggle all lock properties
        obj.set({
            lockMovementX: newState,
            lockMovementY: newState,
            lockRotation: newState,
            lockScalingX: newState,
            lockScalingY: newState,
            lockUniScaling: newState
        });

        // Visual feedback on object
        obj.set('borderColor', newState ? '#ef4444' : '#22c55e');
        obj.set('cornerColor', newState ? '#ef4444' : '#ffffff');
        
        canvas.requestRenderAll();
        updateLockUI();
      });

      canvas.on('selection:created', updateLockUI);
      canvas.on('selection:updated', updateLockUI);
      canvas.on('selection:cleared', updateLockUI);

    // Responsive Canvas Scaling
    function resizeCanvas() {
      const wrapper = document.querySelector('.canvas-wrap');
      // Calculate available width (minus padding)
      const availableWidth = wrapper.clientWidth - 24;
      // Calculate available height (window height minus header/footer estimate)
      const availableHeight = window.innerHeight - 180;

      // Use current internal canvas dimensions
      const baseWidth = canvas.width;
      const baseHeight = canvas.height;
      
      // Determine scale needed to fit both width and height
      const scaleW = availableWidth / baseWidth;
      const scaleH = availableHeight / baseHeight;
      
      // Use the smaller scale to ensure it fits entirely, but don't scale up > 1
      const scale = Math.min(scaleW, scaleH, 1);
      
      // Apply CSS scaling (visual only, keeps internal resolution high)
      const finalW = baseWidth * scale;
      const finalH = baseHeight * scale;
      
      // Update the wrapper and canvas styles
      canvas.setDimensions({ width: finalW + 'px', height: finalH + 'px' }, { cssOnly: true });
      
      // Re-calculate offsets for correct mouse/touch mapping
      canvas.calcOffset();
      canvas.requestRenderAll();
    }
    
    // Listen for window resize
    window.addEventListener('resize', resizeCanvas);
    // Initial call
    setTimeout(resizeCanvas, 100);

    // Keep current background image reference
    let bgImage = null;

    function setBackgroundFromURL(url) {
      if (!url) {
        // Revert to square if clearing background
        canvas.setDimensions({ width: 1024, height: 1024 });
        canvas.setBackgroundImage(null, () => {
            canvas.renderAll();
            resizeCanvas();
        });
        bgImage = null;
        return;
      }
      
      document.body.style.cursor = 'wait';

      // Helper to load image with retry logic
      const attemptLoad = (src, isRetry) => {
        const imgEl = new Image();
        imgEl.crossOrigin = 'anonymous';
        
        imgEl.onload = () => {
          const img = new fabric.Image(imgEl);
          bgImage = img;
          
          // Resize canvas to match image aspect ratio (max 1024px)
          const maxDim = 1024;
          const ar = img.width / img.height;
          let newW, newH;
          
          if (ar >= 1) {
              newW = maxDim;
              newH = maxDim / ar;
          } else {
              newW = maxDim * ar;
              newH = maxDim;
          }
          
          // Update internal canvas size
          canvas.setDimensions({ width: Math.round(newW), height: Math.round(newH) });
          
          // Fit image to canvas
          img.scaleToWidth(canvas.width);
          img.scaleToHeight(canvas.height);
          img.set({ 
              left: canvas.width / 2, 
              top: canvas.height / 2, 
              originX: 'center', 
              originY: 'center', 
              selectable: false, 
              evented: false 
          });

          canvas.setBackgroundImage(img, () => {
              canvas.renderAll();
              resizeCanvas(); // Update CSS display size
              document.body.style.cursor = 'default';
          });
        };
        
        imgEl.onerror = () => {
          if (!isRetry && src.startsWith('http')) {
            // Retry with a CORS proxy
            console.warn('Direct load failed (CORS?), retrying with proxy...');
            attemptLoad('https://api.allorigins.win/raw?url=' + encodeURIComponent(url), true);
          } else {
            document.body.style.cursor = 'default';
            let msg = 'Failed to load background image.';
            if (window.location.protocol === 'file:') {
                msg += '\n\nSince you are opening this file locally, make sure the image file "' + url + '" is in the same folder.';
            } else {
                msg += '\n\nThe server blocked access or the file is missing.';
            }
            msg += '\n\nWorkaround: Use the "Insert Image" button to pick a file from your computer.';
            alert(msg);
          }
        };
        
        imgEl.src = src;
      };

      attemptLoad(url, false);
    }

    // Background dropdown
    const bgSelect = document.getElementById('bgSelect');
    bgSelect.addEventListener('change', (e) => {
      setBackgroundFromURL(e.target.value);
    });

    // Rotate Background Function
    function rotateBackground() {
      if (!canvas.backgroundImage) return;
      
      const bg = canvas.backgroundImage;
      const currentAngle = bg.angle || 0;
      const newAngle = (currentAngle + 90) % 360;
      
      bg.rotate(newAngle);
      
      // Swap canvas dimensions to fit the rotated image
      const w = canvas.getWidth();
      const h = canvas.getHeight();
      canvas.setDimensions({ width: h, height: w });
      
      // Re-center the background image
      bg.set({
        left: canvas.getWidth() / 2,
        top: canvas.getHeight() / 2,
        originX: 'center',
        originY: 'center'
      });
      
      bg.setCoords();
      canvas.requestRenderAll();
      resizeCanvas();
    }
    
    document.getElementById('rotateBgBtn').addEventListener('click', rotateBackground);

    // Canvas resize UI removed â€” canvas size is taken from the <canvas> element or controlled programmatically.

      // Add Text
      const addTextBtn = document.getElementById('addTextBtn');
      addTextBtn.addEventListener('click', () => {
        const text = new fabric.IText('Double-click to Edit', {
          left: canvas.getWidth() / 2,
          top: canvas.getHeight() / 2,
          originX: 'center',
          originY: 'center',
          fontFamily: 'Arial',
          fontSize: 32,
          fill: '#000000',
          stroke: '#ffffff',
          strokeWidth: 6,
          paintFirst: 'stroke'
        });

        // Custom render function to apply destination-out only to the stroke
        text._render = function(ctx) {
            this._setTextStyles(ctx);
            this._renderTextLinesBackground(ctx);
            this._renderTextDecoration(ctx, 'underline');
            this._renderText(ctx);
            this._renderTextDecoration(ctx, 'linethrough');
            this._renderTextDecoration(ctx, 'overline');
        };

        // Select all text on first edit so typing replaces it
        text.isFirstEdit = true;
        text.on('editing:entered', () => {
            if (text.isFirstEdit) {
                text.selectAll();
                text.isFirstEdit = false;
            }
        });

        canvas.add(text);
        canvas.setActiveObject(text);
        canvas.renderAll();
      });

    // Load System Fonts (Desktop) or Scan Common Fonts (Mobile)
    const loadFontsBtn = document.getElementById('loadFontsBtn');
    loadFontsBtn.addEventListener('click', async () => {
      // 1. Try Local Font Access API (Desktop Chrome/Edge)
      if ('queryLocalFonts' in window) {
        try {
          const fonts = await window.queryLocalFonts();
          const families = new Set(fonts.map(f => f.family));
          const sorted = [...families].sort();
          
          const currentVal = fontFamily.value;
          fontFamily.innerHTML = '';
          sorted.forEach(fam => {
            const opt = document.createElement('option');
            opt.value = fam;
            opt.textContent = fam;
            fontFamily.appendChild(opt);
          });
          
          if (families.has(currentVal)) fontFamily.value = currentVal;
          else if (sorted.length > 0) fontFamily.value = sorted[0];
          
          alert(`Successfully loaded ${sorted.length} fonts from your system!`);
          return;
        } catch (err) {
          console.warn('Local Font Access API failed or denied.', err);
        }
      }

      // 2. Fallback: Scan for common fonts using width comparison
      // Since mobile browsers don't expose a list, we check against a known list of popular fonts.
      const fontsToCheck = [
        // Windows / Standard Web
        'Arial', 'Arial Black', 'Bahnschrift', 'Calibri', 'Cambria', 'Comic Sans MS', 'Consolas', 
        'Courier New', 'Franklin Gothic Medium', 'Gabriola', 'Georgia', 'Impact', 'Ink Free', 
        'Lucida Console', 'Microsoft Sans Serif', 'Palatino Linotype', 'Segoe Print', 'Segoe Script', 
        'Segoe UI', 'Sylfaen', 'Tahoma', 'Times New Roman', 'Trebuchet MS', 'Verdana', 
        // macOS / iOS
        'American Typewriter', 'Apple Chancery', 'Arial Narrow', 'Baskerville', 'Big Caslon', 
        'Bodoni 72', 'Book Antiqua', 'Chalkduster', 'Cochin', 'Copperplate', 'Courier', 'Didot', 
        'Futura', 'Geneva', 'Gill Sans', 'Helvetica', 'Helvetica Neue', 'Herculanum', 'Hoefler Text', 
        'Lucida Grande', 'Marker Felt', 'Menlo', 'Monaco', 'Noteworthy', 'Optima', 'Palatino', 
        'Papyrus', 'Phosphate', 'Rockwell', 'SignPainter', 'Snell Roundhand', 'Times', 'Zapfino',
        // Android / Linux / Common
        'Roboto', 'Noto Sans', 'Droid Sans', 'Droid Serif', 'Droid Sans Mono', 'Liberation Sans', 
        'Ubuntu', 'Cantarell', 'Oxygen', 'Fira Sans', 'Source Sans Pro', 'Open Sans'
      ];

      // Helper to detect if a font is installed by comparing widths against fallbacks
      const isFontAvailable = (font) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const text = "abcdefghijklmnopqrstuvwxyz0123456789";
        const baseFonts = ['monospace', 'sans-serif', 'serif'];
        
        for (const base of baseFonts) {
            ctx.font = `72px ${base}`;
            const baseWidth = ctx.measureText(text).width;
            
            ctx.font = `72px "${font}", ${base}`;
            const newWidth = ctx.measureText(text).width;
            
            // If width differs from fallback, the font is likely present
            if (newWidth !== baseWidth) return true;
        }
        return false;
      };

      document.body.style.cursor = 'wait';
      
      // Run in timeout to allow UI update
      setTimeout(() => {
          const available = fontsToCheck.filter(f => isFontAvailable(f));
          const sorted = available.sort();
          
          // Merge with existing options to avoid duplicates
          const existing = new Set(Array.from(fontFamily.options).map(o => o.value));
          
          sorted.forEach(fam => {
              if (!existing.has(fam)) {
                  const opt = document.createElement('option');
                  opt.value = fam;
                  opt.textContent = fam;
                  fontFamily.appendChild(opt);
              }
          });
          
          document.body.style.cursor = 'default';
          alert(`Scanned and found ${available.length} fonts on this device.`);
      }, 100);
    });

    // Load Google Font by Name
    const googleFontInput = document.getElementById('googleFontInput');
    const loadGoogleFontBtn = document.getElementById('loadGoogleFontBtn');
    
    loadGoogleFontBtn.addEventListener('click', () => {
      const name = googleFontInput.value.trim();
      if (!name) return;
      
      // Construct Google Fonts URL
      // e.g. https://fonts.googleapis.com/css2?family=Lobster&display=swap
      const linkHref = `https://fonts.googleapis.com/css2?family=${name.replace(/ /g, '+')}&display=swap`;
      
      // Create link element
      const link = document.createElement('link');
      link.href = linkHref;
      link.rel = 'stylesheet';
      
      link.onload = () => {
        // Add to dropdown
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        fontFamily.appendChild(opt);
        fontFamily.value = name;
        
        // Apply
        applyTextStyles();
        
        // Feedback
        googleFontInput.value = '';
        googleFontInput.placeholder = 'Loaded: ' + name;
        
        // Force Fabric to re-render after a slight delay to ensure font is ready
        setTimeout(() => canvas.requestRenderAll(), 500);
      };
      
      link.onerror = () => {
        alert(`Could not load Google Font "${name}". Please check the spelling exactly as it appears on fonts.google.com.`);
      };
      
      document.head.appendChild(link);
    });

    // Toggle Font Controls
    const toggleFontControlsBtn = document.getElementById('toggleFontControlsBtn');
    const fontControlsExtra = document.getElementById('fontControlsExtra');
    
    toggleFontControlsBtn.addEventListener('click', () => {
        const isHidden = fontControlsExtra.style.display === 'none';
        fontControlsExtra.style.display = isHidden ? 'inline-flex' : 'none';
        toggleFontControlsBtn.style.outline = isHidden ? '2px solid var(--accent)' : 'none';
    });

    // Toggle Edit Controls
    const toggleEditBtn = document.getElementById('toggleEditBtn');
    const editControlsExtra = document.getElementById('editControlsExtra');
    
    toggleEditBtn.addEventListener('click', () => {
        const isHidden = editControlsExtra.style.display === 'none';
        editControlsExtra.style.display = isHidden ? 'inline-flex' : 'none';
        toggleEditBtn.style.outline = isHidden ? '2px solid var(--accent)' : 'none';
    });

    // Toggle Export Controls
    const toggleExportBtn = document.getElementById('toggleExportBtn');
    const exportControlsExtra = document.getElementById('exportControlsExtra');
    
    toggleExportBtn.addEventListener('click', () => {
        const isHidden = exportControlsExtra.style.display === 'none';
        exportControlsExtra.style.display = isHidden ? 'inline-flex' : 'none';
        toggleExportBtn.style.outline = isHidden ? '2px solid var(--accent)' : 'none';
    });

    // Toggle Paragraph Controls
    const toggleParagraphBtn = document.getElementById('toggleParagraphBtn');
    const paragraphControlsExtra = document.getElementById('paragraphControlsExtra');
    
    toggleParagraphBtn.addEventListener('click', () => {
        const isHidden = paragraphControlsExtra.style.display === 'none';
        paragraphControlsExtra.style.display = isHidden ? 'inline-flex' : 'none';
        toggleParagraphBtn.style.outline = isHidden ? '2px solid var(--accent)' : 'none';
    });

    // Font family & size controls apply to active text
    const fontFamily = document.getElementById('fontFamily');
    const fontSize = document.getElementById('fontSize');
    const textBorder = document.getElementById('textBorder');
    const charSpacing = document.getElementById('charSpacing');

    function getInvertedColor(color) {
        if (color === '#000000' || color === 'black' || color === '#000') return '#ffffff';
        return '#000000';
    }

    function applyTextStyles() {
      const obj = canvas.getActiveObject();
      if (!obj || !(obj instanceof fabric.IText || obj instanceof fabric.CurvedText)) return;
      
      const borderW = parseFloat(textBorder.value) || 0;
      const currentFill = obj.fill || '#000000';
      
      obj.set({
        fontFamily: fontFamily.value,
        fontSize: parseInt(fontSize.value, 10) || obj.fontSize,
        charSpacing: parseInt(charSpacing.value, 10) || 0,
        strokeWidth: borderW,
        stroke: borderW > 0 ? getInvertedColor(currentFill) : null
      });
      obj.set('fontWeight', boldOn ? 'bold' : 'normal');
      obj.set('fontStyle', italicOn ? 'italic' : 'normal');
      canvas.requestRenderAll();
    }
    fontFamily.addEventListener('change', applyTextStyles);
    fontSize.addEventListener('change', applyTextStyles);
    textBorder.addEventListener('input', applyTextStyles);
    charSpacing.addEventListener('input', applyTextStyles);

    // Bold & Italic toggles
    let boldOn = false;
    let italicOn = false;
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    function updateToggleStyles() {
      boldBtn.style.outline = boldOn ? '2px solid var(--accent)' : 'none';
      italicBtn.style.outline = italicOn ? '2px solid var(--accent)' : 'none';
    }
    boldBtn.addEventListener('click', () => {
      boldOn = !boldOn; updateToggleStyles(); applyTextStyles();
    });
    italicBtn.addEventListener('click', () => {
      italicOn = !italicOn; updateToggleStyles(); applyTextStyles();
    });

    // Text Alignment
    const alignLeftBtn = document.getElementById('alignLeftBtn');
    const alignCenterBtn = document.getElementById('alignCenterBtn');
    const alignRightBtn = document.getElementById('alignRightBtn');

    function updateAlignmentUI(align) {
      alignLeftBtn.style.outline = align === 'left' ? '2px solid var(--accent)' : 'none';
      alignCenterBtn.style.outline = align === 'center' ? '2px solid var(--accent)' : 'none';
      alignRightBtn.style.outline = align === 'right' ? '2px solid var(--accent)' : 'none';
    }

    function setTextAlign(align) {
      const obj = canvas.getActiveObject();
      if (!obj || !(obj instanceof fabric.IText || obj instanceof fabric.CurvedText)) return;
      obj.set('textAlign', align);
      canvas.requestRenderAll();
      updateAlignmentUI(align);
    }

    alignLeftBtn.addEventListener('click', () => setTextAlign('left'));
    alignCenterBtn.addEventListener('click', () => setTextAlign('center'));
    alignRightBtn.addEventListener('click', () => setTextAlign('right'));

    // Circular Text Feature
    const circularTextBtn = document.getElementById('circularTextBtn');
    // const curveRadius = document.getElementById('curveRadius'); // Removed
    const flipCurve = document.getElementById('flipCurve');
    const flipCurveLabel = document.getElementById('flipCurveLabel');
    // const radiusValue = document.getElementById('radiusValue'); // Removed

    // Custom fabric.js text class that renders text on a curve
    fabric.CurvedText = fabric.util.createClass(fabric.IText, {
      type: 'curved-text',
      
      radius: 200,
      flipped: false,
      
      initialize: function(text, options) {
        options = options || {};
        this.radius = options.radius || 200;
        this.flipped = options.flipped || false;
        this.callSuper('initialize', text, options);
        this.set('lockScalingFlip', true);
        this._updateDimensions();

        // Add custom control for radius
        this.controls = fabric.util.object.clone(fabric.Object.prototype.controls);
        
        this.controls.radius = new fabric.Control({
            x: 0.5,
            y: 0,
            offsetX: 0,
            cursorStyle: 'ew-resize',
            actionHandler: function(eventData, transform, x, y) {
                var target = transform.target;
                var localPoint = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center');
                var newRadius = Math.abs(localPoint.x);
                // Limit min/max
                newRadius = Math.max(50, Math.min(500, newRadius));
                
                target.radius = newRadius; // Set directly to avoid recursive set calls
                target._updateDimensions();
                target.dirty = true;
                return true; // render
            },
            actionName: 'resizing-radius',
            render: function(ctx, left, top, styleOverride, fabricObject) {
                // Custom rendering for the handle
                ctx.save();
                ctx.translate(left, top);
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#22c55e';
                ctx.stroke();
                // Draw "R"
                ctx.fillStyle = '#22c55e';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('R', 0, 1);
                ctx.restore();
            }
        });
      },
      
      _updateDimensions: function() {
        // Calculate dimensions to fit the curved text
        if (this.radius) {
          const diameter = this.radius * 2 + this.fontSize * 2;
          this.width = diameter;
          this.height = diameter;
          this.setCoords(); // Important: Update control positions immediately
        } else {
            this.callSuper('_initDimensions');
        }
      },

      _initDimensions: function() {
          if (this.radius) {
              this._updateDimensions();
          } else {
              this.callSuper('_initDimensions');
          }
      },
      
      set: function(key, value) {
        this.callSuper('set', key, value);
        
        const keys = typeof key === 'object' ? Object.keys(key) : [key];
        if (keys.some(k => ['radius', 'fontSize', 'text', 'fontFamily', 'fontWeight', 'fontStyle', 'flipped', 'charSpacing'].includes(k))) {
          this._updateDimensions();
          this.dirty = true;
        }
        return this;
      },
      
      _renderText: function(ctx) {
        if (!this.radius) {
          this.callSuper('_renderText', ctx);
          return;
        }
        
        const text = this.text;
        const radius = this.radius;
        const flipped = this.flipped;
        const charSpacing = this.charSpacing || 0;
        
        // Set text properties
        ctx.font = this._getFontDeclaration();
        ctx.textBaseline = 'alphabetic';
        
        // Calculate total text width including spacing
        // Fabric charSpacing is in thousands of em
        const spacing = (charSpacing / 1000) * this.fontSize;
        
        let textWidth = 0;
        for (let i = 0; i < text.length; i++) {
            textWidth += ctx.measureText(text[i]).width;
            if (i < text.length - 1) textWidth += spacing;
        }
        
        const totalAngle = textWidth / radius;
        let currentAngle = -totalAngle / 2;
        
        // Adjust for text alignment
        if (this.textAlign === 'left') {
          // currentAngle = 0; // Keep centered for now
        } else if (this.textAlign === 'right') {
          // currentAngle = -totalAngle; 
        }
        
        ctx.save();
        
        // Center of the curve is the center of the object (0,0)
        // No initial translation needed

        // Render each character
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const charWidth = ctx.measureText(char).width;
          const charAngle = currentAngle + (charWidth / 2) / radius;
          
          ctx.save();
          
          // If flipped (Smile), we need to rotate in the opposite direction to maintain Left-to-Right reading order
          ctx.rotate(flipped ? -charAngle : charAngle);
          
          if (flipped) {
            // Smile: Move down to the arc
            ctx.translate(0, radius);
          } else {
            // Rainbow: Move up to the arc
            ctx.translate(0, -radius);
          }
          
          // Draw the character
          if (this.paintFirst === 'stroke') {
            if (this.stroke && this.strokeWidth > 0) {
              ctx.strokeStyle = this.stroke;
              ctx.lineWidth = this.strokeWidth;
              ctx.strokeText(char, -charWidth / 2, 0);
            }
            if (this.fill) {
              ctx.fillStyle = this.fill;
              ctx.fillText(char, -charWidth / 2, 0);
            }
          } else {
            if (this.fill) {
              ctx.fillStyle = this.fill;
              ctx.fillText(char, -charWidth / 2, 0);
            }
            if (this.stroke && this.strokeWidth > 0) {
              ctx.strokeStyle = this.stroke;
              ctx.lineWidth = this.strokeWidth;
              ctx.strokeText(char, -charWidth / 2, 0);
            }
          }
          
          ctx.restore();
          
          currentAngle += (charWidth + spacing) / radius;
        }
        
        ctx.restore();
      },
      
      // Hide cursor and selection to prevent visual artifacts while editing curved text
      renderCursor: function(ctx, boundaries) {
        // No-op
      },
      renderSelection: function(ctx, boundaries) {
        // No-op
      },

      _renderTextDecoration: function(ctx) {
        // Skip text decoration for curved text
      },
      
      _renderTextLinesBackground: function(ctx) {
        // Skip background for curved text
      },
      
      getBoundingRect: function() {
        // Return a bounding rect that accounts for the curve
        if (this.radius) {
          const diameter = this.radius * 2 + this.fontSize * 2;
          const coords = this.calcCoords();
          return {
            left: coords.tl.x,
            top: coords.tl.y,
            width: diameter * this.scaleX,
            height: diameter * this.scaleY
          };
        }
        return this.callSuper('getBoundingRect');
      },
      
      toObject: function() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          radius: this.radius,
          flipped: this.flipped
        });
      }
    });

    fabric.CurvedText.fromObject = function(object, callback) {
      return fabric.Object._fromObject('CurvedText', object, callback, 'text');
    };

    function toggleCircularText() {
      const obj = canvas.getActiveObject();
      if (!obj || !(obj instanceof fabric.IText || obj instanceof fabric.CurvedText)) return;
      
      // Preserve Z-index
      const index = canvas.getObjects().indexOf(obj);

      if (obj instanceof fabric.CurvedText) {
        // Convert back to regular text
        const newText = new fabric.IText(obj.text, {
          left: obj.left,
          top: obj.top,
          fontSize: obj.fontSize,
          fontFamily: obj.fontFamily,
          fontWeight: obj.fontWeight,
          fontStyle: obj.fontStyle,
          fill: obj.fill,
          stroke: obj.stroke,
          strokeWidth: obj.strokeWidth,
          charSpacing: obj.charSpacing,
          paintFirst: obj.paintFirst,
          textAlign: obj.textAlign,
          originX: obj.originX,
          originY: obj.originY,
          angle: obj.angle,
          scaleX: obj.scaleX,
          scaleY: obj.scaleY
        });

        canvas.remove(obj);
        canvas.insertAt(newText, index);
        canvas.setActiveObject(newText);
      } else {
        // Convert to curved text
        const radius = 200; // Default radius
        const flipped = flipCurve.checked;
        
        const curvedText = new fabric.CurvedText(obj.text, {
          left: obj.left,
          top: obj.top,
          fontSize: obj.fontSize,
          fontFamily: obj.fontFamily,
          fontWeight: obj.fontWeight,
          fontStyle: obj.fontStyle,
          fill: obj.fill,
          stroke: obj.stroke,
          strokeWidth: obj.strokeWidth,
          charSpacing: obj.charSpacing,
          paintFirst: obj.paintFirst,
          textAlign: obj.textAlign,
          radius: radius,
          flipped: flipped,
          originX: obj.originX,
          originY: obj.originY,
          angle: obj.angle,
          scaleX: obj.scaleX,
          scaleY: obj.scaleY
        });
        
        canvas.remove(obj);
        canvas.insertAt(curvedText, index);
        canvas.setActiveObject(curvedText);
      }
      
      canvas.requestRenderAll();
      updateCircularTextUI();
    }

    function updateCurveParams() {
      const obj = canvas.getActiveObject();
      if (!obj || !(obj instanceof fabric.CurvedText)) return;
      
      obj.set({
        flipped: flipCurve.checked
      });
      
      obj.dirty = true;
      obj._updateDimensions();
      obj.setCoords();
      
      canvas.requestRenderAll();
    }

    function updateCircularTextUI() {
      const obj = canvas.getActiveObject();
      const isCircular = obj && obj instanceof fabric.CurvedText;
      
      circularTextBtn.style.outline = isCircular ? '2px solid var(--accent)' : 'none';
      flipCurveLabel.style.display = isCircular ? 'inline-flex' : 'none';
      
      if (isCircular) {
        flipCurve.checked = obj.flipped || false;
      }
    }

    circularTextBtn.addEventListener('click', toggleCircularText);
    flipCurve.addEventListener('change', updateCurveParams);

    // Insert image
    const imageInput = document.getElementById('imageInput');
    document.getElementById('insertImageBtn').addEventListener('click', () => imageInput.click());

    // Helper: Compress/Resize image before loading to canvas
    function compressAndLoadImage(file, callback) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const imgObj = new Image();
        imgObj.onload = () => {
          // Create offscreen canvas
          const cvs = document.createElement('canvas');
          const ctx = cvs.getContext('2d');
          
          // Max dimension 1280px is usually safe and < 500KB with JPEG compression
          const MAX_SIZE = 1280; 
          let w = imgObj.width;
          let h = imgObj.height;
          
          if (w > MAX_SIZE || h > MAX_SIZE) {
            if (w > h) {
              h *= MAX_SIZE / w;
              w = MAX_SIZE;
            } else {
              w *= MAX_SIZE / h;
              h = MAX_SIZE;
            }
          }
          
          cvs.width = w;
          cvs.height = h;
          ctx.drawImage(imgObj, 0, 0, w, h);
          
          // Export as JPEG 0.7 quality to reduce size
          const dataURL = cvs.toDataURL('image/jpeg', 0.7);
          callback(dataURL);
        };
        imgObj.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    imageInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      
      document.body.style.cursor = 'wait';

      compressAndLoadImage(file, (dataURL) => {
        fabric.Image.fromURL(dataURL, (img) => {
          document.body.style.cursor = 'default';

          // Use viewport center so it appears where the user is looking (important if zoomed)
          const center = canvas.getVpCenter();

          // Scale to reasonable size (50% of canvas width) to avoid memory issues on mobile
          const maxW = canvas.getWidth() * 0.5;
          const scale = Math.min(1, maxW / img.width);
          img.scale(scale);
          
          // Initial setup: Normal rendering
          img.set({ 
            left: center.x, 
            top: center.y, 
            originX: 'center', 
            originY: 'center',
            objectCaching: false 
          });
          
          canvas.add(img);
          canvas.setActiveObject(img);
          
          // Apply Multiply blend mode
          const curW = img.getScaledWidth();
          const curH = img.getScaledHeight();

          img.set('globalCompositeOperation', 'multiply');
           img.filters.push(new fabric.Image.filters.Grayscale());
          img.applyFilters();

          // Restore dimensions
          if (img.width > 0) {
              img.set({
                  scaleX: curW / img.width,
                  scaleY: curH / img.height
              });
          }

          canvas.requestRenderAll();
        });
      });

      // reset input to allow same file re-insert
      imageInput.value = '';
    });

    // Invert Button Logic
    document.getElementById('invertBtn').addEventListener('click', () => {
      const obj = canvas.getActiveObject();
      if (!obj) return;

      if (obj.type === 'image') {
        // Toggle Invert filter
        const hasInvert = obj.filters.some(f => f instanceof fabric.Image.filters.Invert);
        if (hasInvert) {
          obj.filters = obj.filters.filter(f => !(f instanceof fabric.Image.filters.Invert));
        } else {
          obj.filters.push(new fabric.Image.filters.Invert());
        }
        obj.applyFilters();
      } else if (obj.type === 'i-text' || obj.type === 'text' || obj.type === 'curved-text') {
        // Simple color inversion for text (Black <-> White)
        const currentFill = obj.fill;
        let newFill;
        
        // Check for black-ish colors
        if (currentFill === '#000000' || currentFill === 'black' || currentFill === '#000') {
            newFill = '#ffffff';
        } else {
            newFill = '#000000';
        }
        
        obj.set('fill', newFill);
        
        // Also invert stroke if present
        if (obj.strokeWidth > 0) {
            // If new fill is white, stroke should be black (and vice versa)
            obj.set('stroke', newFill === '#ffffff' ? '#000000' : '#ffffff');
        }
      }
      canvas.requestRenderAll();
    });

    // Duplicate selected
    document.getElementById('duplicateBtn').addEventListener('click', () => {
      const obj = canvas.getActiveObject();
      if (!obj) return;
      
      obj.clone((cloned) => {
        canvas.discardActiveObject();
        cloned.set({
          left: obj.left,
          top: obj.top,
          evented: true,
        });
        
        if (cloned.type === 'activeSelection') {
          // active selection needs a reference to the canvas.
          cloned.canvas = canvas;
          cloned.forEachObject((obj) => {
            canvas.add(obj);
          });
          cloned.setCoords();
        } else {
          canvas.add(cloned);
        }
        
        canvas.setActiveObject(cloned);
        canvas.requestRenderAll();
      });
    });

    // Delete selected
    document.getElementById('deleteBtn').addEventListener('click', () => {
      const obj = canvas.getActiveObject();
      if (!obj) return;
      canvas.remove(obj);
      canvas.discardActiveObject();
      canvas.requestRenderAll();
    });
    // Also support Delete key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Delete') {
        const obj = canvas.getActiveObject();
        if (obj) { canvas.remove(obj); canvas.discardActiveObject(); canvas.requestRenderAll(); }
      }
    });

    // Z-Order controls
    document.getElementById('bringForwardBtn').addEventListener('click', () => {
      const obj = canvas.getActiveObject();
      if (obj) {
        canvas.bringForward(obj);
        canvas.requestRenderAll();
      }
    });
    document.getElementById('sendBackwardsBtn').addEventListener('click', () => {
      const obj = canvas.getActiveObject();
      if (obj) {
        canvas.sendBackwards(obj);
        canvas.requestRenderAll();
      }
    });

    // Export PNG
    function exportPNG() {
      // Render with background included
      const dataURL = canvas.toDataURL({ format: 'png', quality: 1 });
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = 'project-export.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      return dataURL; // Useful for email prefill
    }
    document.getElementById('exportBtn').addEventListener('click', exportPNG);

    // Export SVG
    function exportSVG() {
      const svgContent = canvas.toSVG();
      const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'project-export.svg';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
    document.getElementById('exportSvgBtn').addEventListener('click', exportSVG);

    // Email export
    document.getElementById('emailBtn').addEventListener('click', () => {
      const dataURL = exportPNG();
      // Prefill email. Note: attaching images via mailto isn't reliably supported.
      // We'll include the data URL inline and suggestion text.
      const subject = encodeURIComponent('Editor Export - project-export.png');
      const body = encodeURIComponent(
        'Hi,\\n\\nAttached is the export. If no attachment appears, please use the downloaded file and attach it manually.\\n\\nData URL preview (copy if needed):\\n' + dataURL.substring(0, 100) + '...\\n\\nThanks.'
      );
      const mailto = `mailto:blaychris@gmail.com?subject=${subject}&body=${body}`;
      window.location.href = mailto;
    });

    // Keep toolbar reflecting selected text object
    canvas.on('selection:created', updateToolbar);
    canvas.on('selection:updated', updateToolbar);
    canvas.on('selection:cleared', updateToolbar);

    function updateToolbar() {
      const obj = canvas.getActiveObject();
      const textToolbar = document.getElementById('toolbar-text');
      // const imageToolbar = document.getElementById('toolbar-image'); // Removed
      
      // Reset visibility
      textToolbar.style.display = 'none';
      // imageToolbar.style.display = 'none';

      if (obj) {
        if (obj instanceof fabric.IText || obj instanceof fabric.CurvedText || obj.type === 'text' || obj.type === 'i-text' || obj.type === 'curved-text') {
            textToolbar.style.display = 'flex';
            // Sync values
            fontFamily.value = obj.fontFamily || fontFamily.value;
            fontSize.value = obj.fontSize || fontSize.value;
            textBorder.value = obj.strokeWidth || 0;
            charSpacing.value = obj.charSpacing || 0;
            boldOn = (obj.fontWeight === 'bold');
            italicOn = (obj.fontStyle === 'italic');
            updateToggleStyles();
            updateAlignmentUI(obj.textAlign || 'left');
            updateCircularTextUI();
        } 
        // else if (obj instanceof fabric.Image || obj.type === 'image') {
        //    imageToolbar.style.display = 'flex';
        // }
      }
    }

      // Initial state
      updateToggleStyles();

      // Mobile Pinch Zoom
      const canvasEl = canvas.upperCanvasEl;
      let initialDistance = 0;
      let initialZoom = 1;

      canvasEl.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          e.preventDefault(); // Prevent page zoom
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialZoom = canvas.getZoom();
          canvas.selection = false; // Disable selection box while zooming
        }
      }, { passive: false });

      canvasEl.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          
          if (initialDistance > 0) {
            const scale = currentDistance / initialDistance;
            let newZoom = initialZoom * scale;
            
            // Limit zoom levels (0.1x to 5x)
            if (newZoom > 5) newZoom = 5;
            if (newZoom < 0.1) newZoom = 0.1;
            
            // Zoom to center of the two fingers
            const center = {
              x: (touch1.clientX + touch2.clientX) / 2,
              y: (touch1.clientY + touch2.clientY) / 2
            };
            
            // Convert client coordinates to canvas coordinates
            const rect = canvasEl.getBoundingClientRect();
            const point = new fabric.Point(center.x - rect.left, center.y - rect.top);
            
            canvas.zoomToPoint(point, newZoom);
          }
        }
      }, { passive: false });

      canvasEl.addEventListener('touchend', () => {
        canvas.selection = true; // Re-enable selection
        initialDistance = 0;
      });
    });
  </script>
</body>
</html>
